# 객체 지향 프로그래밍의 개념

### 절차 지향 프로그래밍

- 컴퓨터 프로그램은 명령어의 목록이다. 

- 프로그램은 유기적으로 연결된 **하나의 흐름**이다.

- <span style='color:steelblue'>장점 : </span>순서가 정해져있어 실행이 빠르다.

- <span style='color:salmon'>단점 : </span>변경이 어렵다. → 데이터가 많아지고, 하드웨어가 발전하니 이 방법은 생산성이 너무 낮아

---

### 객체 지향 프로그래밍

- 프로그램을 하나로 연결되게끔 X → 하나하나 따로 독립되게 만드는게 어떨까

- 프로그램은 **여러 개의 독립된 객체**와 객체 간의 **상호작용**으로 이루어진다. 
  
  - 콘서트 = 가수 객체 + 감독 객체 + 관객 객체

- 객체 지향 ⊃ 절차 지향
  
  - 객체 간에도 프로그램 수행 절차가 존재한다.
  
  - A 객체 수행 → B 객체 수행

---

### 객체

- 가수 객체
  
  - 데이터 : 나이, 성별, 앨범, 장르 등
  
  - 메서드 : 노래하기, 춤추기, 작곡하기 등
  
     → 현실의 '가수'를 추상화하여 객체로 만들었다.

- 데이터와 기능(메서드)이 분리된 **추상화**된 구조

---

### 객체 지향 프로그래밍이 필요한 이유

- 현실 세계를 프로그램에 반영하기 위해서는 **추상화**가 필요하다.
  
  - 현실 세계를 추상화하여 프로그래밍

- 객체 자체에 데이터와 행동이 정의되어있다.
  
  - 내부 구조를 몰라도 그냥 객체를 가져와서 개발이 가능
  
  - 다른 객체와 조립가능
  
    → 많은 인원이 참여하는 대규모 소프트웨어 개발 가능

- **개발 용이성, 유지보수 편의성, 신뢰성 → 생산성 증가**

---

### 객체 지향 프로그래밍의 단점

- 설계 시 많은 시간과 노력이 필요해
  
  - 다양한 객체들의 상호 작용을 위해 구조를 잘 짜야됨

- 실행 속도가 절차 지향보다 느림
  
  - 절차 지향이 컴퓨터의 처리구조와 비슷하기 때문에 빠름

---

# OOP의 기초

### CS 관점의 객체

- **Class를 토대로 Object(Instance) 만들고, Object가 실제 메모리에 할당된다.**

- 객체 = 속성 (Data) + 행동 (Method)

- **객체**와 **인스턴스**의 차이점?
  
  - 객체는 그 자체로 객체
  
  - 인스턴스는 '해당 클래스의 인스턴스'
  
  - 예) 클래스 : 가수, 객체 : 지디
  
  - 지디는 객체다. 지디는 가수의 인스턴스다. => O
  
  - 지디는 인스턴스다. => X

---

### 파이썬은 모든 것이 객체로 이루어져있다.

<mark>우리가 사용하는 모든 자료형은 class로 이루어져있다.</mark>

- `state = 'hungry'`

- `type(state)` >>> <class 'str'>

- 클래스 : string, 객체 : state

- 객체 = 데이터와 행동으로 이루어져있다.
  
  - 클래스 : int, str, list, dict 등
  
  - 속성 : str은 문자열로 이루어져있다~, list는 []/요소가 들어있고/순서가 있고 등등
  
  - 행동 : `.replace()`, `.append()` 등등

---

### 객체 비교하기

같은 메모리여야 동일한 것

`==`

- 내용이 같으면 True

`is`

- 동일한 객체를 가리켜야 True

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b, a is b)
>>> True False


a = [1, 2, 3]
b = a                    

print(a == b, a is b)
>>> True True
```

---

### 클래스와 인스턴스의 namespace

특정 속성에 접근하면 **인스턴스 → 클래스** 순으로 탐색

- Class 붕어빵
  
  - 반죽 = 밀가루

- Instance 팥붕어빵, 슈붕어빵, 피자붕어빵

- 팥붕어빵.반죽 
  
  1. 팥붕어빵에 가서 반죽을 찾는다.
  
  2. 붕어빵에 가서 반죽을 찾는다.

---

# 변수

### 인스턴스 변수

- 각 인스턴스들의 고유한 변수

- `__init__` : 인스턴스 변수를 정의하는 함수

- 인스턴스 생성 이후 `instance.변수` 로 할당

- 생성자 = 클래스를 생성할 때 부르는 함수
  
  - 인스턴스 생성하면서 class() 괄호 열고닫음 = 함수를 호출하는 것 = 이 때 실행되는 함수가 생성자

- **self** : 인스턴스 자기자신

---

### 클래스 변수

해당 클래스의 모든 인스턴스가 공통적으로 가지는 변수

- `class.변수`로 접근할 수 있다.

---

# 메서드

- 인스턴스는 인스턴스 메서드와 클래스 메서드 모두 사용할 수 있다.

- 클래스는 클래스 메서드만 사용할 수 있다.

### 인스턴스 메서드

- 인스턴스 변수를 사용하는 함수

- 90% 이상

- 첫 번째 인자로 반드시 `self`(인스턴스 자기자신)가 전달됨.

- 생성자 메서드 : 인스턴스를 만들 때 ! 무언가를 하고 싶다면 사용하는 메서드

<mark>**매직 메서드** : 특정 상황에 자동으로 불리는 메서드</mark>

- 예) 해당 클래스를 문자열처럼 사용해야하는 상황인 경우 자동으로 불리는 메서드
  
  - `__str__`
  
  - print 함수 등에서 사용하면 자동으로 호출되는 메서드

- 예) `len()`에 넣으면 반환하는 값을 설정해주는 메서드
  
  - `__len__`

---

### 클래스 메서드

- 인스턴스엔 필요없고, 클래스 변수를 사용하는 함수

- 첫 번째 인자로 반드시 `cls`(클래스)가 전달됨.

- 메서드 위에 `@classmethod` 로 정의

- 인스턴스에서 사용해도 클래스의 결과나옴

### 정적 메서드

- 인스턴스 변수, 클래스 변수 모두 사용하지 않는 함수


































